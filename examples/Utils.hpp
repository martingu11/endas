#ifndef __ENDAS_EXAMPLES_UTILS_HPP__
#define __ENDAS_EXAMPLES_UTILS_HPP__

#include <Endas/Endas.hpp>
#include <Endas/Error/CovarianceOperator.hpp>
#include <Endas/Algorithm/KalmanSmoother.hpp>
#include <Endas/Algorithm/EnsembleKalmanSmoother.hpp>

#include <vector>
#include <chrono>
#include <iostream>

namespace endas
{


//---------------------------------------------------------------------------------------
// Plotting
//---------------------------------------------------------------------------------------


inline std::vector<double> toVector(const SoftRef<const endas::Array> x)
{
    std::vector<double> vec;
    vec.reserve(x.size());
    for (int i = 0; i != x.size(); i++) vec.push_back(x(i));
    return vec;
}

inline std::vector<double> rangeToVector(int start, int end, int step = 1)
{
    std::vector<double> vec;
    for (int i = 0; i != end; i+=step) vec.push_back(i);
    return vec;
}


/*void plot


lineStyle["color"] = "green";
        fillStyle["color"] = "green";
        plt::plot(xValues, toVector(resultX.row(X)), lineStyle);
        plt::fill_between(xValues, toVector(resultX.row(X) - resultSD.row(X)*1.96), 
                                    toVector(resultX.row(X) + resultSD.row(X)*1.96), 
                                    fillStyle);

*/


//---------------------------------------------------------------------------------------
// Data assmilation
//---------------------------------------------------------------------------------------


/**
 * Generate synthetic data for a so called "twin experiment". 
 *  
 * For a given number of time steps, the call generates the true system state evolution 
 * and synthetic observations. The true state of the system is generated by applying the 
 * evolution model to the initial state. Observations are drawn from the true state using 
 * the observation operator `H` and by adding noise with covariance R.
 */
std::tuple<Array2d, Array2d, std::vector<int>> 
generateTestData(int nsteps, const Ref<const Array> x0,
                 const GenericEvolutionModel& model, double dt,
                 const ObservationOperator& H, const CovarianceOperator& Q, 
                 const CovarianceOperator& R, 
                 int obsInterval = 1);


/**
 * Returns state uncertainty/error derived from error covariance matrix.
 */
inline Array covError(const Ref<const Matrix> cov)
{
    return cov.diagonal().array().sqrt();
}

/**
 * Returns state uncertainty/error derived from an ensemble.
 */
inline Array ensembleError(const Ref<const Array2d> E) 
{
    Array ret(E.rows());
    for (int r = 0; r != E.rows(); r++) 
    {
        double rmean = E.row(r).mean();
        ret(r) = sqrt((E.row(r) - rmean).square().mean());
    }

    return ret;
}


inline Array rmse(const SoftRef<const endas::Array2d> a, const SoftRef<const endas::Array2d> b)
{
    ENDAS_ASSERT(a.cols() == b.cols());
    ENDAS_ASSERT(a.rows() == b.rows());
    return ((a - b).square().colwise().mean()).sqrt(); 
}



std::tuple<Array2d, Array2d> 
runKF(KalmanSmoother& ks, int nsteps, double dt, const Ref<const Array> x0, 
      const Ref<const Array2d> obs, const std::vector<int>& obsTimeSteps,
      const ObservationOperator& H, const CovarianceOperator& P0, 
      const CovarianceOperator& Q, const CovarianceOperator& R);


std::tuple<Array2d, Array2d> 
runEnKF(EnsembleKalmanSmoother& ks, const GenericEvolutionModel& model,
        int nsteps, double dt, const Ref<const Array2d> E0, 
        const Ref<const Array2d> obs, const std::vector<int>& obsTimeSteps,
        const ObservationOperator& H, const CovarianceOperator& Q, 
        const CovarianceOperator& R);





}

#endif