/**
 * @file Utils.hpp
 *
 * Utility functions for simplifying the example code.
 */

#ifndef __ENDAS_EXAMPLES_UTILS_HPP__
#define __ENDAS_EXAMPLES_UTILS_HPP__

#include <Endas/Endas.hpp>
#include <Endas/DA/Model.hpp>
#include <Endas/DA/CovarianceOperator.hpp>
#include <Endas/DA/ObservationManager.hpp>


#include <vector>
#include <chrono>
#include <iostream>

namespace endas
{


//---------------------------------------------------------------------------------------
// Plotting
//---------------------------------------------------------------------------------------


inline std::vector<double> toVector(const SoftRef<const endas::Array> x)
{
    std::vector<double> vec;
    vec.reserve(x.size());
    for (int i = 0; i != x.size(); i++) vec.push_back(x(i));
    return vec;
}

inline std::vector<double> rangeToVector(int start, int end, int step = 1)
{
    std::vector<double> vec;
    for (int i = 0; i != end; i+=step) vec.push_back(i);
    return vec;
}


//---------------------------------------------------------------------------------------
// Data assmilation
//---------------------------------------------------------------------------------------

/** 
 * Observation operator and error covariance.  
 */
struct ObservationOpAndCov
{
    std::shared_ptr<const ObservationOperator> H;
    std::shared_ptr<const CovarianceOperator> R;
};


/**
 * Generates synthetic data for a "twin experiment". 
 *  
 * For a given number of time steps, the call generates the true system state evolution 
 * and synthetic observations. The true state of the system is generated by applying the 
 * evolution model to the initial state. Observations are drawn from the true state using 
 * the observation operator `H` and by adding noise with covariance R.
 * 
 * The function returns tuple `(xt, z)` where `xt` is an `n` x `numSteps` array of the true
 * states stored in columns, `z` is a `std::vector` containing the generated observation 
 * vectors. The entries of `z` may be an empty arrays (i.e. `z[k].size()==0`) if `obsInterval` 
 * is greater than 1 or if the observation operator does not "produce" any observations for 
 * a time step *k*.
 * 
 * @param numSteps       Number of steps for which the true state and observations are generated
 * @param x0             The initial system state   
 * @param model          Dynamic/evolution model of the system
 * @param dt             Time-stepping interval in physical units
 * @param Q              Model error covariance (operator)
 * @param H              Observation operator
 * @param R              Observation error covariance (operator)
 * @param numSpinupSteps The number of model spin-up steps before actual test data is generated
 * @param obsInterval    The interval (in time steps) between consecutive generated observation
 *                       vectors
 */
std::tuple<Array2d, std::vector<Array>> 
generateExampleData(int numSteps, const Ref<const Array> x0,
                    const EvolutionModel& model, double dt,
                    const CovarianceOperator& Q, 
                    const ObservationOperator& H, 
                    const CovarianceOperator& R, 
                    int numSpinupSteps = 0,
                    int obsInterval = 1);


/** 
 * Generates synthetic data for a "twin experiment". 
 * 
 * This function is similar to generateExampleData() but uses a callback to provide the 
 * observation operator H and error covariance R.
 * 
 * @param numSteps       Number of steps for which the true state and observations are generated
 * @param x0             The initial system state   
 * @param model          Dynamic/evolution model of the system
 * @param dt             Time-stepping interval in physical units
 * @param Q              Model error covariance (operator)
 * @param HRfun          Called at every time step for which observations are generated to provide 
 *                       the observation operator and error covariance.   
 * @param numSpinupSteps The number of model spin-up steps before actual test data is generated
 * @param obsInterval    The interval (in time steps) between consecutive generated observation
 *                       vectors
 * 
 * @see generateExampleData() for more information.
 */
std::tuple<Array2d, std::vector<Array>> 
generateExampleData(int numSteps, const Ref<const Array> x0,
                    const EvolutionModel& model, double dt,
                    const CovarianceOperator& Q, 
                    std::function<ObservationOpAndCov(int k)> HRfun,
                    int numSpinupSteps = 0,
                    int obsInterval = 1);




/**
 * Returns state uncertainty/error derived from error covariance matrix.
 */
inline Array covError(const Ref<const Matrix> cov)
{
    return cov.diagonal().array().sqrt();
}

/**
 * Returns state uncertainty/error derived from an ensemble.
 */
inline Array ensembleError(const Ref<const Array2d> E) 
{
    Array ret(E.rows());
    for (int r = 0; r != E.rows(); r++) 
    {
        double rmean = E.row(r).mean();
        ret(r) = sqrt((E.row(r) - rmean).square().mean());
    }

    return ret;
}


inline Array rmse(const SoftRef<const endas::Array2d> a, const SoftRef<const endas::Array2d> b)
{
    ENDAS_ASSERT(a.cols() == b.cols());
    ENDAS_ASSERT(a.rows() == b.rows());
    return ((a - b).square().colwise().mean()).sqrt(); 
}




}

#endif