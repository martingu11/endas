#ifndef __ENDAS_EXAMPLES_UTILS_HPP__
#define __ENDAS_EXAMPLES_UTILS_HPP__

#include <Endas/Endas.hpp>
#include <Endas/DA/CovarianceOperator.hpp>
#include <Endas/DA/Algorithm/KalmanSmoother.hpp>
#include <Endas/DA/Algorithm/EnsembleKalmanSmoother.hpp>

#include <vector>
#include <chrono>
#include <iostream>

namespace endas
{


//---------------------------------------------------------------------------------------
// Plotting
//---------------------------------------------------------------------------------------


inline std::vector<double> toVector(const SoftRef<const endas::Array> x)
{
    std::vector<double> vec;
    vec.reserve(x.size());
    for (int i = 0; i != x.size(); i++) vec.push_back(x(i));
    return vec;
}

inline std::vector<double> rangeToVector(int start, int end, int step = 1)
{
    std::vector<double> vec;
    for (int i = 0; i != end; i+=step) vec.push_back(i);
    return vec;
}


/*void plot


lineStyle["color"] = "green";
        fillStyle["color"] = "green";
        plt::plot(xValues, toVector(resultX.row(X)), lineStyle);
        plt::fill_between(xValues, toVector(resultX.row(X) - resultSD.row(X)*1.96), 
                                    toVector(resultX.row(X) + resultSD.row(X)*1.96), 
                                    fillStyle);

*/


//---------------------------------------------------------------------------------------
// Data assmilation
//---------------------------------------------------------------------------------------


/**
 * Generates synthetic data for a "twin experiment". 
 *  
 * For a given number of time steps, the call generates the true system state evolution 
 * and synthetic observations. The true state of the system is generated by applying the 
 * evolution model to the initial state. Observations are drawn from the true state using 
 * the observation operator `H` and by adding noise with covariance R.
 * 
 * The function returns tuple `(xt, z)` where `xt` is an `n` x `numSteps` array of the true
 * states stored in columns, `z` is a `std::vector` containing the generated observation 
 * vectors. The entries of `z` may be an empty arrays (i.e. `z[k].size()==0`) if `obsInterval` 
 * is greater than 1 or if the observation operator does not "produce" any observations for 
 * a time step *k*.
 * 
 * @param numSteps       Number of steps for which the true state and observations are generated
 * @param x0             The initial system state   
 * @param model          Dynamic/evolution model of the system
 * @param dt             Time-stepping interval in physical units
 * @param H              Observation operator
 * @param Q              Model error covariance (operator)
 * @param R              Observation error covariance (operator) 
 * @param numSpinupSteps The number of model spin-up steps before actual test data is generated
 * @param obsInterval    The interval (in time steps) between consecutive generated observation
 *                       vectors
 */
std::tuple<Array2d, std::vector<Array>> 
generateExampleData(int numSteps, const Ref<const Array> x0,
                    const EvolutionModel& model, double dt,
                    const ObservationOperator& H, const CovarianceOperator& Q, 
                    const CovarianceOperator& R, 
                    int numSpinupSteps = 0,
                    int obsInterval = 1);


/**
 * Returns state uncertainty/error derived from error covariance matrix.
 */
inline Array covError(const Ref<const Matrix> cov)
{
    return cov.diagonal().array().sqrt();
}

/**
 * Returns state uncertainty/error derived from an ensemble.
 */
inline Array ensembleError(const Ref<const Array2d> E) 
{
    Array ret(E.rows());
    for (int r = 0; r != E.rows(); r++) 
    {
        double rmean = E.row(r).mean();
        ret(r) = sqrt((E.row(r) - rmean).square().mean());
    }

    return ret;
}


inline Array rmse(const SoftRef<const endas::Array2d> a, const SoftRef<const endas::Array2d> b)
{
    ENDAS_ASSERT(a.cols() == b.cols());
    ENDAS_ASSERT(a.rows() == b.rows());
    return ((a - b).square().colwise().mean()).sqrt(); 
}



/*std::tuple<Array2d, Array2d> 
runKF(KalmanSmoother& ks, int nsteps, double dt, const Ref<const Array> x0, 
      const Ref<const Array2d> obs, const std::vector<int>& obsTimeSteps,
      const ObservationOperator& H, const CovarianceOperator& P0, 
      const CovarianceOperator& Q, const CovarianceOperator& R);


std::tuple<Array2d, Array2d> 
runEnKF(EnsembleKalmanSmoother& ks, const EvolutionModel& model,
        int nsteps, double dt, const Ref<const Array2d> E0, 
        const Ref<const Array2d> obs, const Ref<const Array2d> obsCoords, 
        const std::vector<int>& obsTimeSteps,
        const ObservationOperator& H, const CovarianceOperator& Q, 
        const CovarianceOperator& R);*/





}

#endif