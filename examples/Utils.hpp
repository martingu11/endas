#ifndef __ENDAS_EXAMPLES_UTILS_HPP__
#define __ENDAS_EXAMPLES_UTILS_HPP__

#include <Endas/Endas.hpp>
#include <Endas/Model/Model.hpp>
#include <Endas/Error/CovarianceOperator.hpp>

#include <vector>

#include <iostream>

namespace endas
{

inline std::vector<double> toVector(const SoftRef<const endas::Array> x)
{
    std::vector<double> vec;
    vec.reserve(x.size());
    for (int i = 0; i != x.size(); i++) vec.push_back(x(i));
    return vec;
}

inline std::vector<double> rangeToVector(int start, int end, int step = 1)
{
    std::vector<double> vec;
    for (int i = 0; i != end; i+=step) vec.push_back(i);
    return vec;
}



/**
 * Generate synthetic data for a so called "twin experiment". 
 *  
 * For a given number of time steps, the call generates the true system state evolution 
 * and synthetic observations. The true state of the system is generated by applying the 
 * evolution model to the initial state. Observations are drawn from the true state using 
 * the observation operator `H` and by adding noise with covariance R.
 */
std::tuple<Array2d, Array2d, std::vector<int>> 
generateTestData(int nsteps, const Ref<const Array> x0,
                 const GenericEvolutionModel& model, double dt,
                 const Ref<const Matrix> H, const CovarianceOperator& Q, 
                 const CovarianceOperator& R, 
                 int obsInterval = 1);



inline auto cov2error(const Ref<const Matrix> cov) -> decltype(cov.diagonal().array().sqrt())
{
    return cov.diagonal().array().sqrt();
}

inline Array rmse(const SoftRef<const endas::Array2d> a, const SoftRef<const endas::Array2d> b)
{
    ENDAS_ASSERT(a.cols() == b.cols());
    ENDAS_ASSERT(a.rows() == b.rows());
    return ((a - b).square().colwise().mean()).sqrt(); 
}


}

#endif