"""
Various utility functions and classes useful for testing.
"""

import math
import numpy as np
from scipy import sparse



def make_data(model, x0, dt, H, Q, R, nsteps, nspin=None):
  """
  Generates true state of a system and synthetic observations for given number of steps.

  The true state is generated by propagating initial state with a model. At each time step,
  observations of the system are generated from the true state by adding random noise.

  Args:
    model         : Evolution model instance for propagating the model state forward in time.
    x0 (n x 1 array): Initial state vector.
    dt (float)    : Time step.
    H             : Observation operator. If not given, operator defined by an identity matrix
                    is assumed (i.e. all state variables are directly observed).
    R             : Observation error covariance operator as an instance of :class:`da.CovarianceOperator`.
    nsteps (int)   : The number of steps to generate data for.
    nspin (int)    : The number of spin-up steps. Optional.


  Returns:
    Tuple (xt, yobs, tk) where `xt` is an n x t array (`t` is the number of time steps) containing true
    model states stored in columns and `yobs` is an k x t array of observations where `k` is the number of
    observations defined by `H`.
  """

  n = model.ndim
  k = H.shape[0]

  assert(x0.ndim == 1)
  assert(len(x0) == n)

  xt = x0

  # Warming up...
  if nspin is not None and nspin > 0:
    for i in range(1, nspin):
      model(xt, dt)
      if Q is not None: xt+= Q.random_multivariate_normal()



  # No observation operator? Assume all variables are observed
  if H is None: H = sparse.eye(n)
  assert(H.shape[1]) == n

  # Generating truth and observations

  xtrue = np.zeros((n, nsteps))
  yobs  = np.zeros((k, nsteps))

  #tk = np.zeros(nsteps)
  time = 0
  for i in range(0, nsteps):
    xtrue[:,i] = xt
    #tk[i] = time
    yt = H.dot(xt)
    yobs[:, i] = yt + R.random_multivariate_normal()

    model(xt, dt)
    if Q is not None: xt += Q.random_multivariate_normal()
    time  = time + dt

  return xtrue, yobs #, tk







def forecast_skill(model, xtrue, xest, dt, fsteps=20, skip=8):
  """
  Computes forecast skill of an assimilation algorithm from estimated
  states.

  Args:
    model : Dynamic model instance
    xtrue (NxT array) : Array containing the true model state
    xest  (NxT array) : Array containing the true model state
    dt (float)    : Model time step
    fsteps (int)  : Number of forecast steps
    skip (int)    : The number of consecutive data points to skip.
                    This exists in order to improve performance on
                    long time series
    """

  n = model.ndim
  nsteps = math.floor(xest.shape[1] / skip)-1
  ferr = np.zeros((nsteps, fsteps))

  for j in range(nsteps):
    k = (j+1) * skip
    x0e   = xest[:, k]
    #jtime = j*dt

    xi = x0e
    for i in range(0, fsteps):      # from time t = 0 to time t = 10days
      ferr[j, i] = np.mean((xi-xtrue[:, k+i])**2)
      xi, dummy = model(xi, dt)

  fskill = np.sqrt(np.mean(ferr, 0))
  return fskill
